INTERPRETATION:
Chaque interprétation d'une ligne respecte les contraintes suivantes :

le premier mot de la ligne est interprété comme le nom de la commande, les autres mots en sont les paramètres ou options ;
chaque mot est séparé par un ou plusieurs caractères de séparation. Par défaut, ces caractères sont l'espace et la tabulation
(modifiable grâce à la variable Internal Field Separator (IFS) ;
la fin de la commande est marquée, soit par un « ; » (si l'on veut placer plusieurs commandes sur la même ligne), soit par un saut de ligne.

Il existe plusieurs types de noms de commande associés à différents degrés de priorité. En suivant l'ordre décroissant des priorités,
lors de l'interprétation de ce premier mot, on trouve :

les alias : ce sont des mots définis comme synonymes d'un autre (groupe de) mot(s). Dans ce cas, l'interpréteur commence par remplacer
le mot par son équivalent. Un exemple d'alias commun est alias ll='ls -alh' qui permet d'appeler ls -alh en n'entrant que ll ;
les commandes internes : ce sont des commandes qui ont été définies dans l'interpréteur. Elles ne font pas l'objet d'un programme séparé.
Par exemple, cd (change directory) ou set sont des commandes internes du shell. Ainsi which set ne retourne pas l'emplacement d'un
fichier binaire correspondant à cette commande, car elle fait partie du programme de Bash ;
les commandes externes, c'est-à-dire les programmes (ou un fichier de commande, en général appelé « script ») stockés sur le disque de la
machine. Par exemple, ls est la commande qui permet de lister les fichiers contenus dans un répertoire donné ; which ls donne l'emplacement
du binaire de ls.
Si Bash ne trouve aucune correspondance dans les alias, les commandes internes ou les commandes externes avec le premier mot de la ligne,
il renvoie un message d'erreur en faisant précéder command not found du mot tapé en tête de ligne.

EXECUTION
Dans le cas d'une commande externe, le shell doit retrouver le programme correspondant à cette commande avant de pouvoir l'exécuter.
Une recherche exhaustive, pour chaque commande, dans tout le système de fichiers prendrait beaucoup trop de temps et rendrait
le système inutilisable dans la pratique. Seul un petit ensemble de répertoires est en fait consulté lors de la recherche du programme
permettant l'exécution de la commande. Ces répertoires sont définis dans une variable d'environnement appelée « $PATH ». Si la commande
n'est pas trouvée dans l'un des répertoires listés dans cette variable, « le PATH », l'exécution se solde par un message d'erreur du type
command not found.

Contrairement à ce qui se passe sous Windows, pour des raisons de sécurité, les shells Unix, dont Bash, n'incluent pas implicitement
le répertoire courant dans le PATH, mais il peut y être placé explicitement. Cela permet d'éviter qu'un individu n'installe dans le
répertoire courant un programme malveillant qui, portant le même nom qu'une commande externe, pourrait s'exécuter à sa place si un
utilisateur tapait cette commande.

Les variables sont référencées en les faisant précéder par le signe $ (exemple echo $HOME).

POUR LES BONUS
A && B
ET logique (&&)	Exécute B, si A réussit.
B si A OK

A || B
Exécute B uniquement si A échoue.
B si A KO

A > fichier
sortie (>)	Exécute la commande A et redirige sa sortie standard (stdout) dans fichier en écrasant son contenu ou en créant
fichier si celui-ci n'existe pas

A >> fichier
sortie (>>)	Exécute la commande A et redirige sa sortie standard à la fin de fichier

A < fichier
entrée (<)	Exécute la commande A en lui passant le contenu de fichier dans son entrée standard (stdin)

--------------------------------------- PIPE ---------------------------------------
#understanding pipe + fork
https://www.geeksforgeeks.org/c-program-demonstrate-fork-and-pipe/#:~:text=pipe()%20is%20used%20for,up%2C%20one%20for%20each%20direction. 

# tuto pour ecrire un shell
https://brennan.io/2015/01/16/write-a-shell-in-c/

# comportement chelou du pipe
https://unix.stackexchange.com/questions/451341/why-does-cd-have-no-effect-if-output-is-piped

# comprendre les inputs et outputs des pipes
https://superuser.com/questions/178796/understanding-how-inputs-are-sent-to-pipes-in-bash/178798#178798

# inputs / outputs
https://www.tutorialspoint.com/unix/unix-io-redirections.htm

# code pour realiser une redirection
http://www.cs.loyola.edu/~jglenn/702/S2005/Examples/dup2.html

# pourquoi utiliser fork et dup2
https://stackoverflow.com/questions/11515399/implementing-shell-in-c-and-need-help-handling-input-output-redirection

# explique bien les pipes
https://www.cs.rutgers.edu/~pxk/416/notes/c-tutorials/dup2.html

# pourquoi on peut pas pipe dans cd
https://askubuntu.com/questions/404141/why-cant-i-pipe-into-cd

# multiple pipes
https://stackoverflow.com/questions/8389033/implementation-of-multiple-pipes-in-c

# comprendre les variables d'environnement
http://supertos.free.fr/supertos.php?page=950


--------------------------------------- NOTES DIVERSES ---------------------------------------

head -n 2 > test10 < scores < harry > test11 | sort < scores | head -n 3 > test12
head -n 2 < harry > test | sort > test2
sort > test2 | head -n 2 > harry < test > test3
head -n 2 < harry > test | sort > test2

echo ok > text.txt salut

l'ordre semble etre ';' > pipe > fork > redirection > execution 
on cree les fichiers des redirections inputs puis on fait les redirections output et emsuiite on exec
les redirections semblent ecraser les pipes >> elles doivent close les FD (ce qui a pour consequence
d'ennvoyer EOF dans le pipe)

reste a voir qui est le pere et le fils dans le pipe (gauche ou droite ?)

>>>>>>>>>> open("input", O_RDONLY); <
comment ouvrir un fichier pour les redirections inputs

>>>>>>>>>>> open("output", O_WRONLY | O_TRUNC | O_CREAT); >
comment ouvrir les fichiers et les mettre a zero (ce que font les redirections output)

>>>>>>>>>>> open("output", O_WRONLY | O_APPEND | O_CREAT); >>


faire un tableau de structure avec surement un identificateur (1/2/3 etc pour redirection, commande, pipe) 
et un pointeur void que l'on cast ensuite qui contiendra soit la commande et ses args, soit le fichier a ouvrir etc

>>>>>>> pour les buiiltins on ne va pas fork et execve pour les executer, juste appeler la fonction. par contre 
bien entendu si on mets un pipe il y a un fork et certains builtins pourront ne plus fonctionner s'ils pas dans
le processus pere lors de leur execution (ex : cd qui doit se trouver a la fin de la ligne pour etre executer)

----------------------------------------- SIGNAUX --------------------------------------------------
Ctrl-C (in older Unixes, DEL) sends an INT signal ("interrupt", SIGINT); by default, this causes the process to terminate.
Ctrl-Z sends a TSTP signal ("terminal stop", SIGTSTP); by default, this causes the process to suspend execution.