--------------------------------------------------------------
CORENTIN 
--------------------------------------------------------------

>>> GNL recupere la ligne de commande qui a été tapée


!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!

>>> 1ere partie qui va checker la syntaxe de la ligne de commande (jusqu'au '\n', point-virugle compris)

◦ ;; >> renvoie une erreur
◦ & ( ) sont des parametres que l'on ne doit pas gerer >> renvoyer une erreur surement
◦ | ou > tout seul sans rien derriere >> penser a renvoyer une erreur de syntax car ca entraine du multiligne
◦ ’ et " doivent marcher comme dans bash, à l’exception du multiligne. >> 1 ne doit pas etre toout seul


------------------------------------------------------------------------
EXCEPTIONS A GERER:
------------------------------------------------------------------------

◦ bash-3.2$ ls=ls ls=ls=ls ls ls=ls
  ls: ls=ls: No such file or directory
  bash-3.2$ ls=ls ls=ls=ls ls
  >> si la variable n'existe pas et qu'elle est avant une fonction (ex : echo) alors aucun resulat. si elle existe
  deja par contre il faut actualiser la valeur de la variable. ls==10 donnera >> ls="=10"

◦ avec export toto (sans mettre toto=quelquechose), le token contenant la variable indefinie devient invalide
  bash-3.2$ echo $totosjj k >>toto vaut surement '\0' du coup >> EN FAIT IL TROUVE PAS LA VARIABLE
k

>>>>>>> les accolades marchent >> pas besoin de les gere ?
bash-3.2$ echo ${tata}salut
1salut


bash-3.2$ echo '\"salut$titi'
\"salut$titi
bash-3.2$ echo \"salut$titi
"salut2
bash-3.2$ echo "\"salut$titi"
"salut2

!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!

>>> 2eme partie qui va decomposer chaque partie séparée par des point-virgules en tokens, que l'on
	representera en tableau de structure 

>>>	SACHANT QUAVANT LE TAB DE STRUCT DANS CETTE PARTIE IL FAUT RETRAITER LA LIGNE JUSQUAU POINT VIRGULE
	ET REMPLACER LES VAR D'ENVIRONNEMENTS
◦ ${VAR} = $VAR >> rempplacer par la variable
◦ valeur de retour des programmes ($? doit marcher comme dans bash) >> equivalent a une variable

>>> le premier token (la commande ou l'executable) semble ne pas tenir compte de la casse. ECHO <=> echo, ./A.OUT <=> ./a.out

>>> LISTE DES SEPARATEURS 
# define F_PIPE -10
# define F_RIGHT -11
# define F_LEFT -12

--------------------------- EXEMPLE COMMANDE SPLIT PAR CODEBRAI EN **CHAR ---------------------------

echo salut > test.txt coucouo \\| head | wc >> test2.txt < test3.txt
echo
salut
-11
test.txt
coucouo
\
-10
head
-10
wc
-11
-11
test2.txt
-12
test3


--------------------------- STRUCTURE POUR STOCKER CHAQUE COMMANDE ---------------------------

typedef struct	s_token
{
	int			type;
	char		**args;
	t_token		*next;
}				t_token;

struct {										>>>>>>>> REDIRECTION INPUT
	type = 0
	char **args = {"input_file", NULL}
}

struct {										>>>>>>>> REDIRECTION OUTPUT
	type = 1
	char **args = {"output_file", NULL}
}

struct {										>>>>>>>> REDIRECTION OUTPUT APPEND
	type = 2
	char **args = {"output_append_file", NULL}
}

struct {										>>>>>>>> COMMANDE
	type = 3
	char **args = {"echo", "-n", "salut", NULL}
}

struct {										>>>>>>>> INDIQUE UN PIPE
	type = 4
	char **args = {NULL}
}

--------------------------------------------------------------
LUCAS
--------------------------------------------------------------

>>> coder les builtins 

◦ echo avec option -n
◦ cd uniquement avec un chemin absolu ou relatif
◦ pwd sans aucune option
◦ export sans aucune option
◦ unset sans aucune option
◦ env sans aucune option ni argument
◦ exit sans aucune option


!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!

>>> pipes et redirections (fonction pipe, dup, dup2 et fork)


!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!

>>> fork + execve pour executer les programmes


!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!!_!

>>> valeur de retour des programmes ($? doit marcher comme dans bash)



--------------------------------------------------------------
AUTRES
--------------------------------------------------------------

>>> ctrl-C, ctrl-D et ctrl-\ doivent afficher le même résultat que dans bash.
	Correspond aux signaux, a voir quand ils doivent etre mis en place mais je
	pense dans la partie du parser donc CORENTIN en theorie
